# genid
Creates unique, sequential, zero-padded ID numbers in a multi-process safe method

## Concurrency
To ensure that the genid function generates sequential numbers, even when run concurrently, I made use of flock to generate a file lock on a file handler, storing the last used genid ID in a file. This ensures that even if thousands of processes are running the genid function simultaneously, the file lock will prevent them from attempting to generate the same ID. The file lock effectively creates a queue for receiving an ID, where each genid process, once it has access to the file lock, reads the last used genid ID, increments it by one, stores the new last used ID in the file, and then releases the lock.

## Performance
The genid function can generate about 165 IDs per second. This means that when genid is being called by many hundreds or thousands of processes simultaneously, there may be a notable delay as processes wait for access to the file lock. The primary constraint is the processing speed between opening and releasing the file lock itself; a more performant language, (especially a compiled one), would likely be able to generate IDs at a higher speed. If even higher performance were desired, running the genid function on a more powerful system, (one with a more powerful CPU and potentially faster attached storage), may also help.

## Testing
Two tests are included in testid.sh. The first uses seq with some printf formatting to generate the expected range, and compares it against what was actually produced. If the output is identical, the test succeeds, if not, the test fails. This test runs very quickly as it doesn't invovle any logic, unlike the real genid, and does a great job at determining whether the output is correct, but can't provide much insight into why genid failed if the test is unsuccessful. The second test breaks down the genid output against the expected output and compares them in a handful of ways, including the number of lines, starting and ending IDs, as well as looking for duplicates or skipped ID numbers. A final report will show which tests were passed or failed, including details on why a test failed.

## Advantages
The primary advantage of this solution is that it is simple; it creates a bottleneck that each process must share in order to ensure that multiple processes do not attempt to generate the same ID or skip IDs. The solution does not require any specialized knowledge to implement, and is relatively straighforward to debug. Once the file lock is in place, the concurrency challenge is almost immediately solved. Furthermore, the solution I employed did not require any additional dependencies and is highly portable. Any system with a recent (>=4) version of Bash installed should be able to run genid and the testid.sh script with no further configuration required.

## Disadvantages
The main disadvantage of this approach is speed; Bash is notably slower than most programming languages, and the difference is stark when comparing against compiled languages in particular. Because the file lock design relies on creating a bottleneck to keep the IDs in sequence, the slow performance of this solution can become a major issue when running thousands of concurrent processes. For example, attempting to launch 100,000 processes running genid would take nearly 10 minutes for the entire sequence to complete. I even included a watching function to wait for the tests to complete before attempting to validate them, as the tests may take several minutes to complete depending on the number of processes spawned.
